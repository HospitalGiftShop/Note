public with sharing class NoteController {
    
    @AuraEnabled
    public static List<Note__c> getNotes(String recordId, String relatedObject) {
        try {
            Set<Id> noteIds = new Set<Id>();
            
            for (Note_Relationship__c link : [SELECT Note__c FROM Note_Relationship__c WHERE Related_Record_Id__c = :recordId AND Related_Object__c = :relatedObject]) {
                noteIds.add(link.Note__c);
            }
            
            if (noteIds.isEmpty()) {
                return new List<Note__c>();
            }
            
            // Enhanced query to get related records info
            List<Note__c> notes = [SELECT Id, Title__c, Category__c, Body__c, Parent_Note__c, ParentId__c, Object_Name__c, Is_Reply__c, Thread_Count__c, CreatedDate, CreatedBy.Name,
                                  (SELECT Id, Related_Record_Id__c, Related_Object__c FROM Note_Relationships__r)
                                  FROM Note__c WHERE Id IN :noteIds OR Parent_Note__c IN :noteIds ORDER BY CreatedDate DESC];
            
            return notes;
            
        } catch (Exception e) {
            throw new AuraHandledException('Error retrieving notes: ' + e.getMessage());
        }
    }
    
    @AuraEnabled
    public static Note__c saveNote(String title, String category, String body, String parentNoteId, String parentRecordId, String objectName, List<String> linkedRecordIds, List<String> relatedObjects) {
        try {
            if (String.isBlank(category) || String.isBlank(body)) {
                throw new AuraHandledException('Category and body are required');
            }
            
            // If title is blank, use the category as the title
            String finalTitle = String.isNotBlank(title) ? title : category;
            
            Note__c note = new Note__c(
                Title__c = finalTitle,
                Category__c = category,
                Body__c = body,
                Parent_Note__c = String.isNotBlank(parentNoteId) ? parentNoteId : null,
                ParentId__c = String.isNotBlank(parentRecordId) ? parentRecordId : null,
                Object_Name__c = String.isNotBlank(objectName) ? objectName : null,
                Is_Reply__c = String.isNotBlank(parentNoteId)
            );
            
            insert note;
            
            List<Note_Relationship__c> links = new List<Note_Relationship__c>();
            for (Integer i = 0; i < linkedRecordIds.size(); i++) {
                links.add(new Note_Relationship__c(
                    Note__c = note.Id,
                    Related_Record_Id__c = linkedRecordIds[i],
                    Related_Object__c = relatedObjects[i]
                ));
            }
            
            if (!links.isEmpty()) {
                insert links;
            }
            
            if (String.isNotBlank(parentNoteId)) {
                updateThreadCount(parentNoteId);
            }
            
            return note;
            
        } catch (Exception e) {
            throw new AuraHandledException('Error saving note: ' + e.getMessage());
        }
    }
    
    @AuraEnabled
    public static Note__c updateNote(String noteId, String title, String category, String body, String parentRecordId, String objectName, List<String> linkedRecordIds, List<String> relatedObjects) {
        try {
            if (String.isBlank(noteId) || String.isBlank(category) || String.isBlank(body)) {
                throw new AuraHandledException('Note ID, category, and body are required');
            }
            
            // If title is blank, use the category as the title
            String finalTitle = String.isNotBlank(title) ? title : category;
            
            Note__c note = new Note__c(
                Id = noteId,
                Title__c = finalTitle,
                Category__c = category,
                Body__c = body,
                ParentId__c = String.isNotBlank(parentRecordId) ? parentRecordId : null,
                Object_Name__c = String.isNotBlank(objectName) ? objectName : null
            );
            
            update note;
            
            if (linkedRecordIds != null && !linkedRecordIds.isEmpty()) {
                delete [SELECT Id FROM Note_Relationship__c WHERE Note__c = :noteId];
                
                List<Note_Relationship__c> links = new List<Note_Relationship__c>();
                for (Integer i = 0; i < linkedRecordIds.size(); i++) {
                    links.add(new Note_Relationship__c(
                        Note__c = noteId,
                        Related_Record_Id__c = linkedRecordIds[i],
                        Related_Object__c = relatedObjects[i]
                    ));
                }
                
                if (!links.isEmpty()) {
                    insert links;
                }
            }
            
            return note;
            
        } catch (Exception e) {
            throw new AuraHandledException('Error updating note: ' + e.getMessage());
        }
    }
    
    @AuraEnabled
    public static void deleteNote(String noteId) {
        try {
            delete [SELECT Id FROM Note_Relationship__c WHERE Note__c = :noteId];
            delete [SELECT Id FROM Note__c WHERE Parent_Note__c = :noteId];
            delete [SELECT Id FROM Note__c WHERE Id = :noteId];
        } catch (Exception e) {
            throw new AuraHandledException('Error deleting note: ' + e.getMessage());
        }
    }
    
    @AuraEnabled
    public static List<Map<String, String>> getLinkedRecords(String noteId) {
        try {
            List<Map<String, String>> linkedRecords = new List<Map<String, String>>();
            
            for (Note_Relationship__c link : [SELECT Related_Record_Id__c, Related_Object__c FROM Note_Relationship__c WHERE Note__c = :noteId]) {
                String recordId = link.Related_Record_Id__c;
                String objectType = link.Related_Object__c;
                
                try {
                    String nameField = getNameFieldForObject(objectType);
                    String query = 'SELECT Id, ' + nameField + ' FROM ' + objectType + ' WHERE Id = \'' + recordId + '\' LIMIT 1';
                    List<SObject> records = Database.query(query);
                    
                    if (!records.isEmpty()) {
                        linkedRecords.add(new Map<String, String>{
                            'Id' => recordId,
                            'Name' => (String) records[0].get(nameField),
                            'RelatedObject' => objectType
                        });
                    }
                } catch (Exception queryEx) {
                    System.debug('Error querying record: ' + queryEx.getMessage());
                }
            }
            
            return linkedRecords;
        } catch (Exception e) {
            throw new AuraHandledException('Error getting linked records: ' + e.getMessage());
        }
    }
    
    @AuraEnabled
    public static Map<String, String> getRecordName(String recordId, String objectType) {
        try {
            String nameField = getNameFieldForObject(objectType);
            String query = 'SELECT Id, ' + nameField + ' FROM ' + objectType + ' WHERE Id = \'' + recordId + '\' LIMIT 1';
            List<SObject> records = Database.query(query);
            
            if (!records.isEmpty()) {
                return new Map<String, String>{
                    'Id' => recordId,
                    'Name' => (String) records[0].get(nameField),
                    'ObjectType' => objectType
                };
            }
            
            return new Map<String, String>{
                'Id' => recordId,
                'Name' => 'Record not found',
                'ObjectType' => objectType
            };
        } catch (Exception e) {
            throw new AuraHandledException('Error getting record name: ' + e.getMessage());
        }
    }
    
    @AuraEnabled
    public static List<Map<String, String>> searchRecords(String searchTerm, String relatedObject) {
        try {
            String nameField = getNameFieldForObject(relatedObject);
            String query = 'SELECT Id, ' + nameField + ' FROM ' + relatedObject + ' WHERE ' + nameField + ' LIKE \'%' + String.escapeSingleQuotes(searchTerm) + '%\' LIMIT 10';
            List<SObject> records = Database.query(query);
            List<Map<String, String>> results = new List<Map<String, String>>();
            
            for (SObject record : records) {
                results.add(new Map<String, String>{
                    'Id' => (String) record.get('Id'),
                    'Name' => (String) record.get(nameField),
                    'RelatedObject' => relatedObject
                });
            }
            
            return results;
        } catch (Exception e) {
            throw new AuraHandledException('Error searching records: ' + e.getMessage());
        }
    }
    
    @AuraEnabled(cacheable=true)
    public static List<String> getCategoryPicklistValues() {
        try {
            List<String> values = new List<String>();
            Schema.DescribeFieldResult fieldResult = Note__c.Category__c.getDescribe();
            
            for (Schema.PicklistEntry entry : fieldResult.getPicklistValues()) {
                if (entry.isActive()) {
                    values.add(entry.getLabel());
                }
            }
            
            return values;
        } catch (Exception e) {
            throw new AuraHandledException('Error getting category values: ' + e.getMessage());
        }
    }
    
    // Helper method to get the correct name field for different objects
    private static String getNameFieldForObject(String objectType) {
        // Map of object types to their name fields
        Map<String, String> objectToNameField = new Map<String, String>{
            'Account' => 'Name',
            'Contact' => 'Name',
            'Opportunity' => 'Name',
            'Lead' => 'Name',
            'Case' => 'Subject',
            'Task' => 'Subject',
            'Event' => 'Subject',
            'Campaign' => 'Name',
            'Product2' => 'Name',
            'Pricebook2' => 'Name',
            'Contract' => 'ContractNumber',
            'Order' => 'OrderNumber',
            'Quote' => 'Name',
            'Asset' => 'Name',
            'Solution' => 'SolutionName',
            'Article' => 'Title'
        };
        
        // Return the appropriate field name, defaulting to 'Name' if not found
        return objectToNameField.containsKey(objectType) ? objectToNameField.get(objectType) : 'Name';
    }
    
    private static void updateThreadCount(String parentNoteId) {
        try {
            Integer count = [SELECT COUNT() FROM Note__c WHERE Parent_Note__c = :parentNoteId];
            update new Note__c(Id = parentNoteId, Thread_Count__c = count);
        } catch (Exception e) {
            System.debug('Error updating thread count: ' + e.getMessage());
        }
    }
}
